<?php
 namespace Dompdf\Adapter; use Dompdf\Canvas; use Dompdf\Dompdf; use Dompdf\Image\Cache; use Dompdf\Helpers; class GD implements Canvas { private $_dompdf; private $_img; private $_imgs; private $_width; private $_height; private $_actual_width; private $_actual_height; private $_page_number; private $_page_count; private $_aa_factor; private $_colors; private $_bg_color; private $_bg_color_array; private $dpi; const FONT_SCALE = 0.75; public function __construct($size = 'letter', $orientation = "portrait", Dompdf $dompdf, $aa_factor = 1.0, $bg_color = array(1, 1, 1, 0)) { if (!is_array($size)) { $size = strtolower($size); if (isset(CPDF::$PAPER_SIZES[$size])) { $size = CPDF::$PAPER_SIZES[$size]; } else { $size = CPDF::$PAPER_SIZES["letter"]; } } if (strtolower($orientation) === "landscape") { list($size[2], $size[3]) = array($size[3], $size[2]); } $this->_dompdf = $dompdf; $this->dpi = $this->get_dompdf()->getOptions()->getDpi(); if ($aa_factor < 1) { $aa_factor = 1; } $this->_aa_factor = $aa_factor; $size[2] *= $aa_factor; $size[3] *= $aa_factor; $this->_width = $size[2] - $size[0]; $this->_height = $size[3] - $size[1]; $this->_actual_width = $this->_upscale($this->_width); $this->_actual_height = $this->_upscale($this->_height); if (is_null($bg_color) || !is_array($bg_color)) { $bg_color = array(1, 1, 1, 0); } $this->_bg_color_array = $bg_color; $this->new_page(); } public function get_dompdf() { return $this->_dompdf; } public function get_image() { return $this->_img; } public function get_width() { return $this->_width / $this->_aa_factor; } public function get_height() { return $this->_height / $this->_aa_factor; } public function get_page_number() { return $this->_page_number; } public function get_page_count() { return $this->_page_count; } public function set_page_number($num) { $this->_page_number = $num; } public function set_page_count($count) { $this->_page_count = $count; } public function set_opacity($opacity, $mode = "Normal") { } private function _allocate_color($color) { $a = isset($color["alpha"]) ? $color["alpha"] : 1; if (isset($color["c"])) { $color = Helpers::cmyk_to_rgb($color); } list($r, $g, $b) = $color; $r *= 255; $g *= 255; $b *= 255; $a = 127 - ($a * 127); $r = $r > 255 ? 255 : $r; $g = $g > 255 ? 255 : $g; $b = $b > 255 ? 255 : $b; $a = $a > 127 ? 127 : $a; $r = $r < 0 ? 0 : $r; $g = $g < 0 ? 0 : $g; $b = $b < 0 ? 0 : $b; $a = $a < 0 ? 0 : $a; $key = sprintf("#%02X%02X%02X%02X", $r, $g, $b, $a); if (isset($this->_colors[$key])) { return $this->_colors[$key]; } if ($a != 0) { $this->_colors[$key] = imagecolorallocatealpha($this->get_image(), $r, $g, $b, $a); } else { $this->_colors[$key] = imagecolorallocate($this->get_image(), $r, $g, $b); } return $this->_colors[$key]; } private function _upscale($length) { return ($length * $this->dpi) / 72 * $this->_aa_factor; } private function _downscale($length) { return ($length / $this->dpi * 72) / $this->_aa_factor; } public function line($x1, $y1, $x2, $y2, $color, $width, $style = null) { $x1 = $this->_upscale($x1); $y1 = $this->_upscale($y1); $x2 = $this->_upscale($x2); $y2 = $this->_upscale($y2); $width = $this->_upscale($width); $c = $this->_allocate_color($color); if (is_array($style) && count($style) > 0) { $gd_style = array(); if (count($style) == 1) { for ($i = 0; $i < $style[0] * $this->_aa_factor; $i++) { $gd_style[] = $c; } for ($i = 0; $i < $style[0] * $this->_aa_factor; $i++) { $gd_style[] = $this->_bg_color; } } else { $i = 0; foreach ($style as $length) { if ($i % 2 == 0) { for ($i = 0; $i < $style[0] * $this->_aa_factor; $i++) { $gd_style[] = $c; } } else { for ($i = 0; $i < $style[0] * $this->_aa_factor; $i++) { $gd_style[] = $this->_bg_color; } } $i++; } } if (!empty($gd_style)) { imagesetstyle($this->get_image(), $gd_style); $c = IMG_COLOR_STYLED; } } imagesetthickness($this->get_image(), $width); imageline($this->get_image(), $x1, $y1, $x2, $y2, $c); } public function arc($x1, $y1, $r1, $r2, $astart, $aend, $color, $width, $style = array()) { } public function rectangle($x1, $y1, $w, $h, $color, $width, $style = null) { $x1 = $this->_upscale($x1); $y1 = $this->_upscale($y1); $w = $this->_upscale($w); $h = $this->_upscale($h); $width = $this->_upscale($width); $c = $this->_allocate_color($color); if (is_array($style) && count($style) > 0) { $gd_style = array(); foreach ($style as $length) { for ($i = 0; $i < $length; $i++) { $gd_style[] = $c; } } if (!empty($gd_style)) { imagesetstyle($this->get_image(), $gd_style); $c = IMG_COLOR_STYLED; } } imagesetthickness($this->get_image(), $width); imagerectangle($this->get_image(), $x1, $y1, $x1 + $w, $y1 + $h, $c); } public function filled_rectangle($x1, $y1, $w, $h, $color) { $x1 = $this->_upscale($x1); $y1 = $this->_upscale($y1); $w = $this->_upscale($w); $h = $this->_upscale($h); $c = $this->_allocate_color($color); imagefilledrectangle($this->get_image(), $x1, $y1, $x1 + $w, $y1 + $h, $c); } public function clipping_rectangle($x1, $y1, $w, $h) { } public function clipping_roundrectangle($x1, $y1, $w, $h, $rTL, $rTR, $rBR, $rBL) { } public function clipping_end() { } public function save() { $this->get_dompdf()->getOptions()->setDpi(72); } public function restore() { $this->get_dompdf()->getOptions()->setDpi($this->dpi); } public function rotate($angle, $x, $y) { } public function skew($angle_x, $angle_y, $x, $y) { } public function scale($s_x, $s_y, $x, $y) { } public function translate($t_x, $t_y) { } public function transform($a, $b, $c, $d, $e, $f) { } public function polygon($points, $color, $width = null, $style = null, $fill = false) { foreach (array_keys($points) as $i) { $points[$i] = $this->_upscale($points[$i]); } $c = $this->_allocate_color($color); if (is_array($style) && count($style) > 0 && !$fill) { $gd_style = array(); foreach ($style as $length) { for ($i = 0; $i < $length; $i++) { $gd_style[] = $c; } } if (!empty($gd_style)) { imagesetstyle($this->get_image(), $gd_style); $c = IMG_COLOR_STYLED; } } imagesetthickness($this->get_image(), $width); if ($fill) { imagefilledpolygon($this->get_image(), $points, count($points) / 2, $c); } else { imagepolygon($this->get_image(), $points, count($points) / 2, $c); } } public function circle($x, $y, $r, $color, $width = null, $style = null, $fill = false) { $x = $this->_upscale($x); $y = $this->_upscale($y); $r = $this->_upscale($r); $c = $this->_allocate_color($color); if (is_array($style) && count($style) > 0 && !$fill) { $gd_style = array(); foreach ($style as $length) { for ($i = 0; $i < $length; $i++) { $gd_style[] = $c; } } if (!empty($gd_style)) { imagesetstyle($this->get_image(), $gd_style); $c = IMG_COLOR_STYLED; } } imagesetthickness($this->get_image(), $width); if ($fill) { imagefilledellipse($this->get_image(), $x, $y, $r, $r, $c); } else { imageellipse($this->get_image(), $x, $y, $r, $r, $c); } } public function image($img_url, $x, $y, $w, $h, $resolution = "normal") { $img_type = Cache::detect_type($img_url, $this->get_dompdf()->getHttpContext()); if (!$img_type) { return; } $func_name = "imagecreatefrom$img_type"; if (!function_exists($func_name)) { if (!method_exists("Dompdf\Helpers", $func_name)) { throw new \Exception("Function $func_name() not found.  Cannot convert $type image: $img_url.  Please install the image PHP extension."); } $func_name = "\\Dompdf\\Helpers::" . $func_name; } $src = @call_user_func($func_name, $img_url); if (!$src) { return; } $x = $this->_upscale($x); $y = $this->_upscale($y); $w = $this->_upscale($w); $h = $this->_upscale($h); $img_w = imagesx($src); $img_h = imagesy($src); imagecopyresampled($this->get_image(), $src, $x, $y, 0, 0, $w, $h, $img_w, $img_h); } public function text($x, $y, $text, $font, $size, $color = array(0, 0, 0), $word_spacing = 0.0, $char_spacing = 0.0, $angle = 0.0) { $x = $this->_upscale($x); $y = $this->_upscale($y); $size = $this->_upscale($size) * self::FONT_SCALE; $h = $this->get_font_height_actual($font, $size); $c = $this->_allocate_color($color); $text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $text); $text = mb_encode_numericentity($text, array(0x0080, 0xff, 0, 0xff), 'UTF-8'); $font = $this->get_ttf_file($font); imagettftext($this->get_image(), $size, $angle, $x, $y + $h, $c, $font, $text); } public function javascript($code) { } public function add_named_dest($anchorname) { } public function add_link($url, $x, $y, $width, $height) { } public function add_info($label, $value) { } public function set_default_view($view, $options = array()) { } public function get_text_width($text, $font, $size, $word_spacing = 0.0, $char_spacing = 0.0) { $font = $this->get_ttf_file($font); $size = $this->_upscale($size) * self::FONT_SCALE; $text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $text); $text = mb_encode_numericentity($text, array(0x0080, 0xffff, 0, 0xffff), 'UTF-8'); list($x1, , $x2) = imagettfbbox($size, 0, $font, $text); return $this->_downscale($x2 - $x1) + 1; } public function get_ttf_file($font) { if ( stripos($font, ".ttf") === false ) { $font .= ".ttf"; } if (!file_exists($font)) { $font_metrics = $this->_dompdf->getFontMetrics(); $font = $font_metrics->getFont($this->_dompdf->getOptions()->getDefaultFont()) . ".ttf"; if (!file_exists($font)) { if (strpos($font, "mono")) { $font = $font_metrics->getFont("DejaVu Mono") . ".ttf"; } elseif (strpos($font, "sans") !== false) { $font = $font_metrics->getFont("DejaVu Sans") . ".ttf"; } elseif (strpos($font, "serif")) { $font = $font_metrics->getFont("DejaVu Serif") . ".ttf"; } else { $font = $font_metrics->getFont("DejaVu Sans") . ".ttf"; } } } return $font; } public function get_font_height($font, $size) { $size = $this->_upscale($size) * self::FONT_SCALE; $height = $this->get_font_height_actual($font, $size); return $this->_downscale($height); } private function get_font_height_actual($font, $size) { $font = $this->get_ttf_file($font); $ratio = $this->_dompdf->getOptions()->getFontHeightRatio(); list(, $y2, , , , $y1) = imagettfbbox($size, 0, $font, "MXjpqytfhl"); return ($y2 - $y1) * $ratio; } public function get_font_baseline($font, $size) { $ratio = $this->_dompdf->getOptions()->getFontHeightRatio(); return $this->get_font_height($font, $size) / $ratio; } public function new_page() { $this->_page_number++; $this->_page_count++; $this->_img = imagecreatetruecolor($this->_actual_width, $this->_actual_height); $this->_bg_color = $this->_allocate_color($this->_bg_color_array); imagealphablending($this->_img, true); imagesavealpha($this->_img, true); imagefill($this->_img, 0, 0, $this->_bg_color); $this->_imgs[] = $this->_img; } public function open_object() { } public function close_object() { } public function add_object() { } public function page_text() { } public function stream($filename, $options = null) { $img = $this->_imgs[0]; if (isset($options['page']) && isset($this->_imgs[$options['page'] - 1])) { $img = $this->_imgs[$options['page'] - 1]; } if ($this->_aa_factor != 1) { $dst_w = $this->_actual_width / $this->_aa_factor; $dst_h = $this->_actual_height / $this->_aa_factor; $dst = imagecreatetruecolor($dst_w, $dst_h); imagecopyresampled($dst, $img, 0, 0, 0, 0, $dst_w, $dst_h, $this->_actual_width, $this->_actual_height); } else { $dst = $img; } if (!isset($options["type"])) $options["type"] = "png"; $type = strtolower($options["type"]); header("Cache-Control: private"); $filename = str_replace(array("\n", "'"), "", basename($filename, ".$type")); switch ($type) { case "jpg": case "jpeg": $filename .= ".jpg"; break; case "png": default: $filename .= ".png"; break; } $attachment = (isset($options["Attachment"]) && $options["Attachment"]) ? "attachment" : "inline"; $encoding = mb_detect_encoding($filename); $fallbackfilename = mb_convert_encoding($filename, "ISO-8859-1", $encoding); $encodedfallbackfilename = rawurlencode($fallbackfilename); $encodedfilename = rawurlencode($filename); $contentDisposition = "Content-Disposition: $attachment; filename=\"" . $encodedfallbackfilename . "\""; if ($encodedfallbackfilename !== $encodedfilename) { $contentDisposition .= "; filename*=UTF-8''$encodedfilename"; } header($contentDisposition); switch ($type) { case "jpg": case "jpeg": if (!isset($options["quality"])) $options["quality"] = 75; header("Content-type: image/jpeg"); imagejpeg($dst, '', $options["quality"]); break; case "png": default: header("Content-type: image/png"); imagepng($dst); break; } if ($this->_aa_factor != 1) imagedestroy($dst); } public function output($options = null) { $img = $this->_imgs[0]; if (isset($options['page']) && isset($this->_imgs[$options['page'] - 1])) { $img = $this->_imgs[$options['page'] - 1]; } if ($this->_aa_factor != 1) { $dst_w = $this->_actual_width / $this->_aa_factor; $dst_h = $this->_actual_height / $this->_aa_factor; $dst = imagecreatetruecolor($dst_w, $dst_h); imagecopyresampled($dst, $img, 0, 0, 0, 0, $dst_w, $dst_h, $this->_actual_width, $this->_actual_height); } else { $dst = $img; } if (!isset($options["type"])) { $options["type"] = "png"; } $type = $options["type"]; ob_start(); switch ($type) { case "jpg": case "jpeg": if (!isset($options["quality"])) { $options["quality"] = 75; } imagejpeg($dst, '', $options["quality"]); break; case "png": default: imagepng($dst); break; } $image = ob_get_clean(); if ($this->_aa_factor != 1) { imagedestroy($dst); } return $image; } } 